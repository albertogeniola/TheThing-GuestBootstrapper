# Guest Agent
The Guest Agent is the module of the architecture that takes care of automating the installation of a given installer (via UI recognition and heuristics) while monitoring the behavior of the binaries being run.
To do so, the agent must reside within the machine used for the analysis (regardless if physical or virtual), and should run with highest privileges in order to control every resource exposed by the operating system.

Since each operating system exposes resources to programs in different ways, the Guest Agent is the only platform dependant module of the architecture. While the system has been designed to support many distinct Sandbox types, at the moment it only supports Windows 7 32bit.   

## Long story short: how does it work.
Each Guest Controller might adopt different implementation choises, based on the specific target operating system. However, we can summarize from a high level perspective, how they work.

As stated above, each host controller has two main tasks: __automate the installation__ and __monitor the behavior of the process__ being automated. Such tasks are generally implemented by two distinct software components (respectively handling automation and resource monitoring), talking each other.
 
In order to automate the installation procedures, the Guest Agent usually relies on some computer vision techniques, such as shape-recognition and text-recognition (OCR). 
That is, a background process scans the windows appearing on the desktop, applies some image filters and tries to detect rectangular shapes.
Such shapes are then passed through the OCR engine, which extracts text from within in (english is the only one supported so far). Then, some platform dependant code is run in order to acquire even more info about visual items (buttons, checkboxes) and so on. 
Then, collected data is passed through a ranking-model, that decides which is the best interaction to perform in order to make the installation proceed. Such decision is based on experience-derived heuristics. To give an idea, rectangular shapes containing the _Next_ | _Install_ | _Continue_ | _Finish_ text are preferred over other shapes.
Next, the Guest Agent performs the interaction with the selected item (it might be a mouse Click, for instance) and the entire process is looped again. 
At each iteration of the loop, the Agent stores some information regarding the UI, in order to detect interaction loops. Nevertheless, it communicates with the resource monitoring component in order to decide when to interact with the UI (e.g. when the process is idle, waiting for user's input).

In the meanwhile, the resource monitoring component will monitor the behavior of the processes involved by the installer. The monitoring of low level resources is highly platform dependent, so there is no general way of doing that. Moreover, there might even be different ways of implementing such control on the same operating system. 
For instance, on Windows 7, we decided to rely on DLL injection and API Hooking. Every process that is run by the installer is injected with a custom DLL, which Hooks system calls by running our code before and after the system call. By selecting a set of relevant system calls to monitor, we are able to understand the mechanics of the process.

From a general point of view, the monitoring system must collect information about file system access, process hierarchies and other platform dependant resources (i.e. Windows Registry). Network can also be handled at this level. However, the gateway sniffer already collects a good amount of information by sniffing traffic generated by each guest, so network monitoring is not mandatory at this level. 

## Guest Agent bootstrap
There are two ways for installing the Guest Agents on the Sandbox machines: _static bootstrap_ and _dynamic bootstrap_.

The first method, _static bootstrap_, consists in installing a specific version of the Guest Agent on the image of the machine. In practice, the user selects a specific Guest Agent, and configures it to run at startup with highest privileges. To do so, it needs to know beforehand the network address of HostController. 
In fact, the Guest Agent requires two parameters to run: the IP address and TCP port of the HostController service, which is running on the HostController. Therefore, those parameters are hard-coded into the startup script of the Sandbox. When using an high number of sandboxes with multiple HostController and different topologies, it might become difficult to set up all those addresses manually.
Moreover, if the user changes the network topology or the HostController address, it must then manually change such parameters for every disk image that is in place.

In order to mitigate such maintenance problems, _dynamic bootstrap_ is advised. This method is based on a tiny bootstrap python service (thus cross-platform), that is installed on the Sandbox image.
The user simply needs to install the bootstrapper on the disk-image of the Sandbox and set it up to run at startup with highest privileges. 
At boot time, the bootstrap will broadcast a discovery message on the local network, specifying the OS type, version and systme architecture. 
The sniffer, which resides on the same LAN, will respond to that, providing:
- An URL where to download the Guest Agent for the specific combination of system/version/architecture (if available)
- The IP:PORT combination of the HostController in charge of such guest

Then, the bootstrapper will download the GuestAgent from given URL and will run it, specifying as arguments the IP:PORT parameters received from sniffer.

Dynamic bootstrap introduces the overhead of downloading the Guest Agent before every analysis. Download time depends on the link capacity of the guests and on the storage location of the Guest Agent. In order to speed this process up, the HostController pushes to the sniffer all the supported Guest Agents. Therefore the sniffer will provide URL pointing to itself. 
This means that Guest Agents are distributed through the private LAN connecting Sandboxes and Sniffer. It is worth noticing that download time might not represent an issue when using paravirtualized network adapters (i.e. Virtualbox) when both the sniffer and guests reside on the same hardware node.      
